/*
 * DATA STRUCTURES EXTENSION
 * 
 * This extension provides functions for working with and manipulating
 * data structures and collections. It includes utilities for
 * measuring, inspecting, and transforming structured data.
 * 
 * The functions in this extension handle operations on iterables,
 * series, and other composite data types.
 * 
 * @author: @RestRegular
 * @version: 1.0.0
 * @extension: ds
 */
import(dt="datatype", ops="ops")

fun size(arg): int {
    /*
     * Returns the size/length of an iterable data structure.
     * 
     * This function works with various iterable types including
     * arrays, lists, series, maps, and other collections to
     * determine their element count or length.
     * 
     * @param arg: The iterable data structure to measure
     * @return: Integer representing the number of elements
     * @throws: TypeError if argument is not iterable
     */
    encapsulated
}

fun copy(arg): any {
    /*
     * Creates a shallow copy of the input data structure.
     *
     * Returns a new data structure containing the same elements
     * as the original. For nested structures, only the top-level
     * elements are copied; nested references remain shared.
     *
     * @param arg: The data structure to copy
     * @return: A new copy of the input data structure
     * @throws: TypeError if argument cannot be copied
     */
    encapsulated
}

fun unpack(arg): series {
    /*
     * Unpacks a data structure into a series format.
     *
     * Converts the input argument into a series type, which is
     * a sequential data structure suitable for iteration and
     * sequential processing. This is particularly useful for
     * working with variable argument structures or converting
     * between different collection types.
     *
     * @param arg: The data structure to unpack into a series
     * @return: Series representation of the input data
     */
    dt.setType(arg, "series")
    ret arg
}

fun isEmpty(arg): bool {
    /*
     * Checks if a data structure is empty.
     *
     * Determines whether the given iterable contains no elements.
     * This is equivalent to checking if size(arg) == 0.
     *
     * @param arg: The data structure to check
     * @return: True if the structure has no elements, false otherwise
     * @throws: TypeError if argument is not iterable
     */
    ret size(arg) == 0
}

fun top(arg): any {
    /*
     * Returns the last element of a data structure.
     *
     * For sequential data structures (arrays, lists, series, etc.),
     * returns the element at the highest index. If the structure
     * is empty, returns null.
     *
     * @param arg: The data structure to get the last element from
     * @return: The last element or null if empty
     * @throws: TypeError if argument is not iterable
     */
    if (isEmpty(arg)) {
        ret null
    }
    ret arg[size(arg) - 1]
}

fun repStr(arg, times: int): str {
    /*
     * Repeats a string multiple times and concatenates the results.
     *
     * Creates a new string by repeating the input string the specified
     * number of times. If times is 0 or negative, returns an empty string.
     *
     * @param arg: The string to repeat
     * @param times: The number of times to repeat the string
     * @return: Concatenated string result of the repetition
     */
    var result: str = ""
    for ({var i: int = 0; i < times; i++}) {
        result += arg
    }
    ret result
}

fun repList(arg, times: int): list {
    /*
     * Creates a list by repeating an element multiple times.
     *
     * Generates a new list containing the specified element repeated
     * the given number of times. The resulting list will have 'times'
     * elements, all equal to the input argument.
     *
     * @param arg: The element to repeat in the list
     * @param times: The number of times to repeat the element
     * @return: List containing the repeated elements
     */
    var result: list = []
    for ({var i: int = 0; i < times; i++}) {
        result += [arg]
    }
    ret result
}

fun repeat(times: int, handler: funi[int][any]): void {
    /*
     * Executes a handler function repeatedly for a specified number of times.
     *
     * The handler function receives one parameter:
     * - current iteration index
     *
     * @param times: The number of times to execute the handler
     * @param handler: Callback function with signature (index: int): any
     */
    encapsulated
}

fun forInRange(start: int, end: int, handler: funi[int, bool, bool][any],
               sep: int = 1): void {
    /*
     * Iterates over a numeric range with a specified step size.
     *
     * Executes the handler function for each value in the range [start, end)
     * with the specified step increment. The handler receives:
     * - current value
     * - boolean indicating if this is the first iteration
     * - boolean indicating if this is the last iteration
     *
     * @param start: Starting value of the range (inclusive)
     * @param end: Ending value of the range (exclusive)
     * @param handler: Callback function with signature (value: int, isFirst: bool,
     *                 isLast: bool): any
     * @param sep: Step size between iterations (cannot be 0)
     * @throws: ValueError if step size is zero
     */
    if sep == 0 {
        fun sout(*args, end="\n"): void {
            encapsulated
        }
        sout("The sep cannot be 0")
        ret
    }
    var isIncreasing: bool = sep > 0
    var next: int = 0
    for ({var i: int = start; i < end; i += sep}) {
        next = i + sep
        var isEnd = false
        if (isIncreasing && next > end) || (isIncreasing == false && \
            next < end) {
            isEnd = true
        }
        if handler(i, i == start, isEnd) == false {
            break
        }
    }
}

fun iter(iterData, handler: funi[any, int, int, .*][any],
         reverse: bool = false): bool {
    /*
     * Iterates through iterable data and applies handler to each item.
     *
     * Processes each element in the iterable data structure by calling
     * the handler function with the current element, its index, and
     * the total length of the iterable. The handler also receives named
     * parameters isStart and isEnd.
     *
     * @param iterData: The iterable data structure to process
     * @param handler: Callback function with signature (item: any, index: int,
     *                 length: int, ...): any. Return false to stop iteration.
     * @param reverse: If true, iterates in reverse order. Default: false (forward iteration)
     * @return: True if iteration completed, false if stopped early
     * @throws: TypeError if iterData is not iterable
     */
    var res = true, iterLength: int
    if dt.isIter(iterData) {
        iterLength = size(iterData)
        if (reverse) {
            for ({var i = iterLength - 1; i >= 0; i--}) {
                if handler(iterData[i], i, iterLength, isStart=i == iterLength - 1,
                    isEnd=i == 0) == false {
                    res = false
                    break
                }
            }
        } else {
            for ({var i = 0; i < iterLength; i++}) {
                if handler(iterData[i], i, iterLength, isStart=i == 0,
                    isEnd=i == iterLength - 1) == false {
                    res = false
                    break
                }
            }
        }
    }
    ret res
}

fun join(iterData, sep: str = ""): str {
    /*
     * Joins elements of an iterable into a single string.
     *
     * Concatenates all elements of the iterable data structure into
     * a string, with the specified separator between each element.
     *
     * @param iterData: The iterable containing elements to join
     * @param sep: The separator string to place between elements. Default: ""
     * @return: String containing all joined elements
     * @throws: TypeError if iterData is not iterable
     */
    var result: str = ""
    iter(iterData, (item, index, length, _) -> {
        result += item
        if index < length - 1 {
            result += sep
        }
    })
    ret result
}

fun joins(*args, sep: str = ""): str {
    /*
     * Joins multiple arguments into a single string.
     *
     * Concatenates all provided arguments into a string, with the
     * specified separator between each argument. This function
     * accepts variable arguments rather than a single iterable.
     *
     * @param args: Variable number of arguments to join
     * @param sep: The separator string to place between arguments. Default: ""
     * @return: String containing all joined arguments
     */
    ret join(args, sep)
}

fun listAppend(listData, item): void {
    /*
     * Appends an item to the end of a list.
     *
     * Modifies the original list by adding the specified item to the end.
     *
     * @param listData: The list to modify
     * @param item: The item to append to the list
     * @throws: TypeError if listData is not a list
     */
    encapsulated
}

fun listRemove(listData, index: int): void {
    /*
     * Removes an element from a list by its index.
     *
     * Modifies the original list by removing the element at the
     * specified index. The list will be re-indexed after removal,
     * so subsequent elements will shift left.
     *
     * @param listData: The list to modify
     * @param index: The position of the element to remove (0-based)
     * @throws: TypeError if listData is not a list
     * @throws: IndexError if index is out of bounds
     */
    encapsulated
}

fun dictRemove(dictData: dict, key): void {
    /*
     * Removes a key-value pair from a dictionary by its key.
     *
     * Modifies the original dictionary by removing the entry associated
     * with the specified key. No error is thrown if the key does not exist
     * in the dictionary.
     *
     * @param dictData: The dictionary to modify
     * @param key: The key of the entry to remove
     * @throws: TypeError if dictData is not a dictionary
     */
    encapsulated
}

fun iterRemove(iterData, index): void {
    /*
     * Removes an element from an iterable data structure based on its type.
     *
     * Dispatches to the appropriate removal function based on the type of
     * iterable:
     * - Uses listRemove() for lists and strings
     * - Uses dictRemove() for dictionaries (where index acts as the key)
     *
     * Prints an error message if the iterable type is unsupported.
     *
     * @param iterData: The iterable to modify (list, string, or dictionary)
     * @param index: For lists/strings: 0-based index of element to remove;
     *               For dictionaries: key of entry to remove
     */
    var iterType = dt.type(iterData)
    if dt.isIter(iterData) {
        if iterType == dt.DT.TP_LIST || iterType == dt.DT.TP_STR {
            listRemove(iterData, index)
            ret
        } elif iterType == dt.DT.TP_DICT {
            dictRemove(iterData, index)
            ret
        }
    }
    fun sout(*args, end="\n"): void {
        encapsulated
    }
    sout("Invalid iterable data type: ", iterType)
}

fun dictKeys(dictData: dict): list {
    /*
     * Retrieves a list of all keys from a dictionary.
     *
     * Extracts and returns a list containing all keys from the input
     * dictionary. The order of keys in the list matches their internal
     * storage order in the dictionary.
     *
     * @param dictData: The dictionary to extract keys from
     * @return: A list containing all keys of the dictionary
     * @throws: TypeError if the input is not a dictionary type
     */
    encapsulated
}

fun dictValues(dictData: dict): list {
    /*
     * Retrieves a list of all values from a dictionary.
     *
     * Extracts and returns a list containing all values from the input
     * dictionary. The order of values in the list matches the storage
     * order of their corresponding keys in the dictionary.
     *
     * @param dictData: The dictionary to extract values from
     * @return: A list containing all values of the dictionary
     * @throws: TypeError if the input is not a dictionary type
     */
    encapsulated
}

fun iterContains(iterData, checkItem): bool {
    /*
     * Checks if an iterable data structure contains a specified item.
     *
     * Iterates through the iterable data structure to determine if the target
     * item exists. For dictionaries, it checks for the existence of the item
     * as a key; for other iterables (lists, arrays, strings, etc.),
     * it checks for the existence of the item as an element.
     *
     * @param iterData: The iterable data structure to check
     * @param checkItem: The target item to search for
     * @return: True if the target item exists, false otherwise
     * @throws: TypeError if the input is not an iterable type
     */
    var result: bool = false
    iter(iterData, (item, _, _, _) -> {
        if item == checkItem {
            result = true
        }
    })
    ret result
}

fun sort(numList: list, reverse: bool = false): list {
    /*
     * Sorts a list using quicksort algorithm.
     *
     * Creates a new sorted list from the input list. By default, sorts in
     * ascending order. If reverse is true, sorts in descending order.
     *
     * @param numList: The list to sort
     * @param reverse: If true, sorts in descending order. Default: false (ascending)
     * @return: A new sorted list
     */
    var quickSort: funi[list, bool][list] = (arr: list, reverse: bool): list -> {
        if size(arr) <= 1 {
            ret arr
        }
        var pivot = arr[0],
            less: list = [],
            greater: list = [],
            i = 1
        while i < size(arr) {
            if (arr[i] <= pivot && !reverse) || (arr[i] > pivot && reverse) {
                less += arr[i]
            } else {
                greater += arr[i]
            }
            i ++
        }
        ret quickSort(less, reverse) + [pivot] + quickSort(greater, reverse)
    }
    ret quickSort(numList, reverse)
}

class Iterable {
    /*
     * Abstract base class for iterable data structures.
     *
     * Provides a common interface for different types of iterable
     * data structures. Defines virtual methods that must be implemented
     * by subclasses.
     */
    ctor () {
        /*
         * Constructor for the Iterable class.
         * Initializes the base iterable object.
         */
        pass
    }

    fun size(): int public virtual {
        /*
         * Virtual method to get the size of the iterable.
         *
         * Must be implemented by subclasses.
         *
         * @return: The number of elements in the iterable
         */
        ret null
    }

    fun get(): any public virtual {
        /*
         * Virtual method to get the underlying data.
         *
         * Must be implemented by subclasses.
         *
         * @return: The underlying data structure
         */
        ret null
    }

    fun toStr(): str public virtual {
        /*
         * Virtual method to convert the iterable to a string representation.
         *
         * Must be implemented by subclasses.
         *
         * @return: String representation of the iterable
         */
        ret null
    }

    fun empty(): bool public {
        /*
         * Checks if the iterable is empty.
         *
         * @return: True if the iterable has no elements, false otherwise
         */
        ret this.size() == 0
    }
}

class List: Iterable {
    /*
     * Enhanced list class that extends the Iterable base class.
     *
     * Provides additional functionality for working with lists,
     * including sorting, mapping, filtering, reducing, and various utility methods.
     */
    var data: list private,
        length: int private,
        compareHandler: funi[any, any][int] private = null,
        plusHandler: funi[any, any][any] private = null

    ctor () {
        /*
         * Default constructor for the List class.
         * Creates an empty list with initial length 0.
         */
        super()
        this.data = []
        this.length = 0
    }

    ctor (data: list) {
        /*
         * Constructor for the List class with initial data.
         *
         * @param data: Initial list data to populate the List object
         */
        super()
        this.data = data
        this.length = size(data)
    }

    fun get(): list public overwrite {
        /*
         * Gets the underlying list data.
         *
         * @return: The underlying list data structure
         */
        ret this.data
    }

    fun sort(sortHandler: funi[any, any][int] = null, reverse: bool = false): List public {
        /*
         * Sorts the list in place using either a custom sort handler or default comparison.
         *
         * @param sortHandler: Optional custom comparison function with signature (a: any, b: any): int
         *                     Returns negative if a < b, 0 if a == b, positive if a > b
         * @param reverse: If true, sorts in descending order. Default: false (ascending)
         * @return: The modified List object
         */
        sortHandler = ops.orVal(sortHandler, this.compareHandler)
        if sortHandler == null {
            this.data = sort(this.data, reverse)
        } else {
            var quickSort: funi[list, bool][list] = \
                (arr: list, reverse: bool): list -> {
                    if size(arr) <= 1 {
                        ret arr
                    }
                    var pivot = arr[0]
                    var less: list
                    var greater: list
                    var i = 1
                    while i < size(arr) {
                        var compareResult = sortHandler(arr[i], pivot)
                        if (compareResult <= 0 && !reverse) || (compareResult > 0 && reverse) {
                            less += arr[i]
                        } else {
                            greater += arr[i]
                        }
                        i ++
                    }
                    ret quickSort(less, reverse) + [pivot] + quickSort(greater, reverse)
                }
            this.data = quickSort(this.data, reverse)
        }
        ret this
    }

    fun append(item): List {
        /*
         * Appends an item to the end of the list.
         *
         * Modifies the list in place and returns the modified List object
         * for method chaining.
         *
         * @param item: The item to append
         * @return: The modified List object
         */
        listAppend(this.data, item)
        this.length += 1
        ret this
    }

    fun remove(index: int): List {
        /*
         * Removes an element from the list by its index.
         *
         * Modifies the list in place and returns the modified List object
         * for method chaining.
         *
         * @param index: The 0-based index of the element to remove
         * @return: The modified List object
         */
        iterRemove(this.data, index)
        this.length -= 1
        ret this
    }

    fun size(): int public overwrite {
        /*
         * Gets the size of the list.
         *
         * @return: The number of elements in the list
         */
        ret this.length
    }

    fun toStr(): str public overwrite {
        /*
         * Gets the string representation of the list.
         *
         * @return: String representation of the list
         */
        ret "" + this.data
    }

    fun mapper(handler: funi[any][any]): List {
        /*
         * Creates a new List by applying a transformation function to each element.
         *
         * @param handler: Transformation function with signature (item: any): any
         * @return: A new List containing the transformed elements
         */
        var newList: List = List()
        iter(this.data, (item, _, _, _) -> {
            newList.append(handler(copy(item)))
        })
        ret newList
    }

    fun filter(handler: funi[any][bool]): List {
        /*
         * Filters the list based on a handler function.
         *
         * @param handler: A function that takes an element and returns true or false
         * @return: A new List containing elements for which the handler returns true
         */
        var newList: List = List()
        iter(this.data, (item, _, _, _) -> {
            var copiedItem = copy(item)
            if handler(copiedItem) {
                newList.append(copiedItem)
            }
        })
        ret newList
    }

    fun toFmtStr(transHandler: funi[any][any]): str {
        /*
         * Creates a formatted string representation by applying a transformation
         * function to each element before converting to string.
         *
         * @param transHandler: Transformation function with signature (item: any): any
         * @return: Formatted string representation of the list
         */
        ret this.mapper(transHandler).toStr()
    }

    fun contains(item): bool public {
        /*
         * Checks if the list contains a specific item.
         *
         * @param item: The item to check for
         * @return: True if the item exists in the list, false otherwise
         */
        ret iterContains(this.data, item)
    }

    fun setCompareHandler(handler: funi[any, any][int]): List {
        /*
         * Sets a custom comparison handler for sorting operations.
         *
         * @param handler: Comparison function with signature (a: any, b: any): int
         * @return: The List object for method chaining
         */
        this.compareHandler = handler
        ret this
    }

    fun setPlusHandler(handler: funi[any, any][any]): List {
        /*
         * Sets a custom addition handler for sum operations.
         *
         * @param handler: Addition function with signature (a: any, b: any): any
         * @return: The List object for method chaining
         */
        this.plusHandler = handler
        ret this
    }

    fun max(compareHandler: funi[any, any][int] = null): any public {
        /*
         * Finds the maximum element in the list.
         *
         * @param compareHandler: Optional custom comparison function with signature (a: any, b: any): int
         *                        If not provided, uses default comparison
         * @return: The maximum element in the list, or null if the list is empty
         */
        if this.empty() {
            ret null
        }
        var max = copy((this.data)[0])
        compareHandler = ops.orVal(compareHandler, this.compareHandler)
        if compareHandler {
            iter(this.data, (item, _, _, _) -> {
                if compareHandler(item, max) > 0 {
                    max = item
                }
            })
        } else {
            iter(this.data, (item, _, _, _) -> {
                if item > max {
                    max = item
                }
            })
        }
        ret max
    }

    fun min(compareHandler: funi[any, any][int] = null): any public {
        /*
         * Finds the minimum element in the list.
         *
         * @param compareHandler: Optional custom comparison function with signature (a: any, b: any): int
         *                        If not provided, uses default comparison
         * @return: The minimum element in the list, or null if the list is empty
         */
        if this.empty() {
            ret null
        }
        var min = copy((this.data)[0])
        compareHandler = ops.orVal(compareHandler, this.compareHandler)
        if compareHandler {
            iter(this.data, (item, _, _, _) -> {
                if compareHandler(item, min) < 0 {
                    min = item
                }
            })
        } else {
            iter(this.data, (item, _, _, _) -> {
                if item < min {
                    min = item
                }
            })
        }
        ret min
    }

    fun sum(plusHandler: funi[any, any][any] = null): any public {
        /*
         * Calculates the sum of all elements in the list using reduce.
         *
         * @param plusHandler: Optional custom addition function with signature (a: any, b: any): any
         *                     If not provided, uses default addition operator
         * @return: The sum of all elements in the list, or null if the list is empty
         */
        if this.empty() {
            ret null
        }
        plusHandler = ops.orVal(plusHandler, this.plusHandler)
        plusHandler = ops.orVal(plusHandler, (front, back) -> { ret front + back })
        ret this.reduce(plusHandler)
    }

    fun reduce(reducer: funi[any, any][any], initialValue: any = null): any {
        /*
         * Reduces the list to a single value by applying a reducer function cumulatively.
         *
         * @param reducer: A function that takes two arguments (accumulator and current item)
         *                 and returns a new accumulator value.
         * @param initialValue: Optional initial value for the accumulator. If not provided,
         *                      the first element of the list is used as the initial value.
         * @return: The final reduced value
         */
        var result = initialValue
        var hasInitialValue = initialValue != null
        iter(this.data, (item, _, _, _) -> {
            if !hasInitialValue {
                result = item
                hasInitialValue = true
            } else {
                result = reducer(result, item)
            }
        })
        ret result
    }

    fun splice(other): List public {
        /*
         * Concatenates this list with another list or List object.
         *
         * Creates a new List containing elements from both lists.
         *
         * @param other: Another list or List object to concatenate with this list
         * @return: A new List containing concatenated elements
         */
        if dt.type(other) == dt.DT.TP_LIST {
            ret this.spliceBuiltinList(other)
        } else {
            ret this.spliceBuiltinList(other)
        }
    }

    fun spliceNR(other): void public {
        /*
         * Concatenates this list with another list or List object in place.
         *
         * Modifies the current list object by appending elements from the other list.
         *
         * @param other: Another list or List object to concatenate with this list
         */
        var result = this.splice(other)
        this.data = result.get()
        this.length = result.size()
    }

    fun spliceList(other: List): List {
        /*
         * Concatenates this list with another List object.
         *
         * Creates a new List containing elements from both lists.
         *
         * @param other: Another List object to concatenate with this list
         * @return: A new List containing concatenated elements
         */
        ret List(this.data + other.get())
    }

    fun spliceBuiltinList(other: list): List {
        /*
         * Concatenates this list with a built-in list.
         *
         * Creates a new List containing elements from both lists.
         *
         * @param other: A built-in list to concatenate with this list
         * @return: A new List containing concatenated elements
         */
        ret List(this.data + other)
    }

    fun find(predicate: funi[any, int, .*][bool]): any {
        /*
         * Finds the first element in the list that satisfies the predicate.
         *
         * @param predicate: A function that takes an element, its index and other infos,
         *                   it returns true or false
         * @return: The first matching element, or null if no match is found
         */
        var result
        iter(this.data, (item, index, _, kwargs) -> {
            var copiedItem = copy(item)
            if predicate(copiedItem, index, unpack(kwargs)) {
                result = copiedItem
                ret false
            }
        })
        ret result
    }

    fun at(index: int): any public {
        /*
         * Accesses an element in the list by its index.
         *
         * Supports negative indexing, where -1 refers to the last element,
         * -2 to the second-to-last, and so on.
         *
         * @param index: The 0-based index of the element to access
         * @return: The element at the specified index, or null if index is out of bounds
         */
        if index < 1 - this.length || index >= this.length {
            ret null
        }
        if index < 0 {
            index += this.length
        }
        ret (this.data)[index]
    }

    fun unique(): List public {
        /*
         * Removes duplicate elements from the list.
         *
         * @return: A new List with unique elements
         */
        var uniqueList: List = List()
        iter(this.data, (item, _, _, _) -> {
            if !uniqueList.contains(item) {
                uniqueList.append(item)
            }
        })
        ret uniqueList
    }

    fun slice(start: int, end: int, sep: int = 1): List public {
        /*
         * Returns a new List containing elements from the start index to the end index (exclusive).
         *
         * @param start: Start index (inclusive)
         * @param end: End index (exclusive)
         * @param sep: Step size between elements (default: 1)
         * @return: A new List containing the sliced elements
         */
        var res: List = List()
        if end < start {
            ret res
        }
        forInRange(start, end, (index, _, _) -> {
            res.append(copy(this.at(index)))
        }, sep)
        ret res
    }

    fun reversed(): List public {
        /*
         * Returns a new List with elements in reverse order.
         *
         * @return: A new List with reversed elements
         */
        var res: List = List()
        iter(this.data, (item, _, _, _) -> {
            res.append(copy(item))
        }, true)
        ret res
    }

    fun reverse(): List public {
        /*
         * Reverse element orders and return self
         *
         * @return: List
         */
        var res: List = List()
        iter(this.data, (item, _, _, _) -> {
            res.append(item)
        }, true)
        this.data = res.data
        ret this
    }
}

export(
    size, copy, unpack, isEmpty, top, repStr, repList,
    repeat, forInRange, join, joins, iter, listAppend,
    listRemove, dictRemove, iterRemove, dictKeys, sort,
    dictValues, iterContains,

    Iterable, List
)
